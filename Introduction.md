# 引言  

如果你是一名有经验的 _C++_ 程序员，并且是我一样的话，那么你最初接触到 _C++11_ 时的想法一定是：“是的，是的，这就是  
_C++_，只不过多了一些特性而已”。但是当你学的越多，你就越会被改动的范围所惊讶到。_auto_ 声明、基于范围的 _for_ 循环、  
_lambad_ 表达式和右值引用改变了 _C++_ 的外貌，更不用说新的并发特性了。还有一些习惯用法的改变。_0_ 和 _typedefs_ 退出  
了，_nullptr_ 和 _alias_ 声明被引入了。枚举现在又作用域了。相比于内置指针来说，智能指针是更好的。移动对象通常比拷  
贝对象是要好的。

关于 _C++11_ 就有很多需要学习的内容，更不用说 _C++14_ 了。
 
更有趣地是，关于高效使用这些新特性有很多需要学习的内容。如果你需要的是 **_modern_** _C++_ 特性的基础资料的话，那么资料  
是丰富的，但是如果你正在寻找的是如何利用这些新特性以去创建正确的、高效的、可维护的和可移植的软件的指导方针的话，  
那么寻找这样的资料是非常有挑战性的。这就是本书的由来。本书不致力于描述 _C++11_ 和 _C++14_ 的特性，而是致力于了这些  
特性的高效应用。

本书的内容被分成了称为 _Items_ 的指导方针。想要明白各种形式的类型推导？想要指导何时该何时不该使用类型推导？你对以  
下内容感兴趣吗？为什么 _const_ 成员函数应该是线程安全的呢？如何使用 _std::unique_ptr_ 实现 _Pimpl Idiom_？为什么你  
应该在 _lambad_ 避免使用默认捕获模式呢？_std::atomic_ 和 _volatile_ 的区别是什么？这些答案都在这里。更进一步。它们  
都是平台独立的且符合标准的答案。本书是关于可移植 _C++_ 的。

本书中的 _Items_ 是指导方针，但不是规则，因为指导方针是有例外的。每一个 _Item_ 的最重要的并不是它所提供的建议，而  
是这些建议背后的逻辑依据。一旦你了解了这些 _Items_，你就能确定你的项目场景是否有理由去违反这些 _Items_ 的指导方针。  
本书真正的目标不是告诉你去做什么或者避免去做什么，而是要去传递 _C++11_ 和 _C++14_ 如何运行的更深层次的理解。

## 术语和惯例

为了确保我们彼此理解，重要的是在一些术语上达成一致，令人讽刺的是从 **_C++_** 这个词开始。_C++_ 共有 _4_ 个官方版本，每  
一个后都跟着一个相应的 _ISO_ 标准被采用的年份：_C++98_、_C++03_、_C++11_ 和 _C++14_。_C++98_ 和 _C++03_ 只在一些技术细节  
上不同，所以在本书中一起将它们称为 _C++98_。当我提及 _C++11_ 时，我指的是 _C++11_ 和 _C++14_，因为 _C++14_ 实际上只是  
 _C++11_ 的超集。如果我只是提到了 _C++_ 的话，我正在做一个适用于所有语言版本的广泛陈述。

![Image](./image/image1.jpg)  

因此，我可能会说：_C++_ 是非常注重效率的，所有版本都是这样；_C++98_ 缺少并发的支持，_C++98_ 和 _C++03_ 都支持；_C++11_  
支持 _lambad_ 表达式，_C++11_ 和 _C++14_ 都支持；_C++14_ 提供广义函数的返回类型推导，只有 _C++14_ 提供。

_C++11_ 的最广泛的特性大概是移动语义，移动语义的基础是区分左值表达式和右值表达式。这是因为右值表示是适合移动操作  
的对象，而左值通常则不是。在概念上，尽管在实际中不总是，右值对应的是函数所返回的临时对象，而左值对应的则是你可  
以通过名字或者通过指针或左值引用来引用的对象。

一个可以确定一个表达式是否是左值的方法是：你是否可以获取这个表达式的地址。如果可以，它通常就是左值。如果不可以，  
它通常不是左值。这个方法的一个友好特性是可以帮助你记住：一个表达式的类型是和这个表达式是左值还是右值无关的。也  
就是说，给定一个类型 _T_，你可以有类型 _T_ 的左值和右值。更重要的是当处理右值引用类型的形参时牢记这个方法，因为形参  
本身就是一个左值：  
```C++
  class Widget {
  public:
    Widget(Widget&& rhs);   // rhs is an lvalue, though it has
    …                       // an rvalue reference type
  };
```  
在这里，在 _Widget_ 的移动构造函数中获取 _rhs_ 的地址是完全有效的，尽管 _rhs_ 的类型是一个右值引用。类似地，所有的  
形参都是左值。

这个代码片段描述了我通常遵循的一些惯例：
* 类的名字是 _Widget_。当我想要一个任意的用户定义的类型时，我就会使用 _Widget_。除非我需要展示这个类的特定细节  
  以外，否则我就会在不声明这个类的情况下就去使用它。  
* 我使用形参名 _rhs_ 来表示 **_right-hand side_**。这是我喜欢在 _move operations_（即为：移动构造函数和移动操作符  
  函数）和 _copy operations_（即为：拷贝构造函数和拷贝操作符函数）上喜欢用的形参名，其中我也用它做为二元操作  
  符函数的右侧形参：  
  ```C++
    Matrix operator+(const Matrix& lhs, const Matrix& rhs);
  ```  
  不要惊讶，我会用 _lhs_ 代表 **_left-hand side_**。
* 我在代码中和注释中应用了特殊的格式，以去引起你的注意。在上面的 _Widget_ 的移动构造函数中，我已经高亮了 _rhs_  
  的声明和注释中 _rhs_ 是左值的那部分。高亮代码既不是固有地好或坏。高亮代码只是你应该特别关注的代码。
* 我使用 **_..._** 来表示 **_其他代码会在这里_**。这个窄省略和在 _C++11_ 中的可变参数模板所对应的源码中所使用的宽省略是不  
  同的。这听起来是令人困惑的，但并不是。例如：  
  ```C++
    template<typename... Ts>                // these are C++
    void processVals(const Ts&... params)   // source code
    {                                       // ellipses

      …                                     // this means "some
                                            // code goes here"
    }
  ```

_processVals_ 的声明展示了：当我在模板中声明类型形参时，我使用的是 _typename_，但这仅仅是个人喜好；关键字 _class_  
也可以工作。在我展示来自于 _C++_ 标准库的代码的场合中，我使用 _class_ 来声明类型形参，因为标准库就是这么做的。

当使用另一个相同类型的对象来初始化一个新对象时，这个新对象被称为初始化对象的副本，甚至这个副本是通过移动构造函  
数所创建的。遗憾地是，在 _C++_ 中没有区分拷贝构造的副本和移动构造的副本的术语。  
```C++
  void someFunc(Widget w);    // someFunc's parameter w
                              // is passed by value

  Widget wid;                 // wid is some Widget
  someFunc(wid);              // in this call to someFunc,
                              
                              // w is a copy of wid that's
                              // created via copy construction

  someFunc(std::move(wid));   // in this call to SomeFunc,
                              // w is a copy of wid that's
                              // created via move construction
```  

右值的副本通常是移动构造得到的，而左值的副本则通常是拷贝构造得到的。如果你只知道一个对象是另一个对象的副本的话，  
那么是不能说构造这个副本是如何的代价大的。例如，在不知道是左值还是右值会传递给 _someFunc_ 的情况下，就不能说创建  
形参 _w_ 是如何的代价大的。你还必须得知道移动和拷贝 _Widget_ 的成本。  
  
在函数调用中，在调用处所传递的表达式是函数的实参。这个实参被用来初始化函数的形参。在上面的第一个 _somefunc_ 调用  
中的实参是 _wid_。在第二个调用中的实参是 _std::move(wid)_。在所有的调用中形参都是 _w_。区分形参和实参是重要的，因为  
形参是左值，但是初始化形参所用的实参可以是左值或者右值。这在 **_完美转发_** 过程中更为重要，在其中所传递给第一个函数  
的实参是被传递给第二个函数的，从而保留原始实参的右值性或者左值性。完美转发会在 [_Item 30_](./Item%2030.md) 中详细讨论。
 
精心设计的函数是异常安全的，这意味着至少提供了基本异常函数的保证（即为：基本保证）。这样的函数确保调用者：即使  
抛出了一个异常，程序不变量也是保持不变的（即为：没有数据结构被损坏，同时也是没有资源被泄露的。提供了强异常安全  
保证的函数，也就是强保证，确保调用者：如果出现了一个异常的话，那么程序的状态也会保持在它被调用之前的那样。
  
当我提及函数对象时，通常说的是支持有 _operator()_ 成员函数的类型的一个对象。换句话说，一个表现得像是函数的对象。   
偶尔，我也会在稍微更广义的意义上来使用这个术语，以去表示任何可以使用非成员函数调用语法而调用的东西，这个语法是：  
**_functionName(arguments)_**。这个广义定义不仅包括支持有 _operator()_ 的对象，还包括函数指针和 _C_ 函数指针。这个狭  
义定义来自于 _C++98_，而这个广义定义来自于 _C++11_。通过增加成员函数指针来进一步广义化，这会产生被称为 _callable_  
的对象。你通常可以忽略这个友好的区别，然后简单地认为函数对象和可调用对象是一些可以使用函数调用语法而进行调用的  
东西。
  
 _lambda_ 表达式所创建的函数对象被称为 _closures_。没有必要去区分 _lambda_ 表达式和它所创建的 _closures_。类似地,我也  
 很少区分函数模板（即为：生成函数的模板）和模板函数（即为：根据函数模板生成的函数）。同理类模板和模板类。  
.....................................................................................................  
_C++_ 中的很多事都可以被声明和定义。声明是介绍了名字和类型，但是没有给出细节，比如：是在哪里存储的或者是如何实现  
的：  
  



